# --- Imports ---
import numpy as np
import pandas as pd
from pandas import DataFrame
from functools import reduce
from freqtrade.strategy import IStrategy, merge_informative_pair
import talib.abstract as ta
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

# ===================================================================================================
# ==                                                                                               ==
# ==    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó                        ==
# ==   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù     ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë                        ==
# ==   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë                        ==
# ==   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë                        ==
# ==   ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë ‚ïö‚ïê‚ïù ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù    ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó                   ==
# ==    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù     ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù   ‚ïö‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù                   ==
# ==                                                                                               ==
# ==    N·ªòI DUNG PH√ÇN T√çCH SMC ƒê∆Ø·ª¢C T√çCH H·ª¢P TR·ª∞C TI·∫æP ƒê·ªÇ TR√ÅNH XUNG ƒê·ªòT TH∆Ø VI·ªÜN                  ==
# ==                                                                                               ==
# ===================================================================================================

def analyze_smc_features(df: DataFrame, swing_lookback: int = 20) -> DataFrame:
    """
    H√†m n√†y ph√¢n t√≠ch v√† th√™m c√°c c·ªôt SMC v√†o DataFrame.
    ƒê√¢y l√† phi√™n b·∫£n th·ªß c√¥ng ƒë·ªÉ thay th·∫ø th∆∞ vi·ªán 'smartmoneyconcepts'.
    
    Args:
        df (DataFrame): B·∫£ng d·ªØ li·ªáu OHLCV.
        swing_lookback (int): S·ªë n·∫øn ƒë·ªÉ x√°c ƒë·ªãnh ƒë·ªânh/ƒë√°y.

    Returns:
        DataFrame: B·∫£ng d·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c th√™m c√°c c·ªôt ph√¢n t√≠ch SMC.
    """
    
    # --- 1. X√°c ƒë·ªãnh Swing Highs & Swing Lows ---
    df['swing_high'] = df['high'].rolling(window=swing_lookback*2+1, center=True).max() == df['high']
    df['swing_low'] = df['low'].rolling(window=swing_lookback*2+1, center=True).min() == df['low']
    
    # --- 2. X√°c ƒë·ªãnh Break of Structure (BOS) v√† Change of Character (CHoCH) ---
    last_swing_high = np.nan
    last_swing_low = np.nan
    trend = 0  # 1 for bullish, -1 for bearish
    
    bos_choch = []
    
    for i in range(len(df)):
        is_swing_high = df['swing_high'].iloc[i]
        is_swing_low = df['swing_low'].iloc[i]
        current_high = df['high'].iloc[i]
        current_low = df['low'].iloc[i]
        
        signal = 0 # 1: Bullish BOS, -1: Bearish BOS, 2: Bullish CHoCH, -2: Bearish CHoCH
        
        if is_swing_high:
            last_swing_high = current_high
        if is_swing_low:
            last_swing_low = current_low

        if trend == 1 and not np.isnan(last_swing_low) and current_low < last_swing_low:
            signal = -2 # Bearish CHoCH
            trend = -1
            last_swing_high = np.nan # Reset
        elif trend == -1 and not np.isnan(last_swing_high) and current_high > last_swing_high:
            signal = 2 # Bullish CHoCH
            trend = 1
            last_swing_low = np.nan # Reset
        elif not np.isnan(last_swing_high) and current_high > last_swing_high:
            signal = 1 # Bullish BOS
            trend = 1
            last_swing_low = np.nan # Reset
        elif not np.isnan(last_swing_low) and current_low < last_swing_low:
            signal = -1 # Bearish BOS
            trend = -1
            last_swing_high = np.nan # Reset
            
        bos_choch.append(signal)

    df['bos_choch_signal'] = bos_choch
    df['BOS'] = df['bos_choch_signal'].apply(lambda x: 1 if x == 1 else (-1 if x == -1 else 0))
    df['CHOCH'] = df['bos_choch_signal'].apply(lambda x: 1 if x == 2 else (-1 if x == -2 else 0))

    # --- 3. X√°c ƒë·ªãnh Order Blocks (OB) ---
    # Bullish OB: N·∫øn gi·∫£m cu·ªëi c√πng tr∆∞·ªõc m·ªôt ƒë·ª£t tƒÉng gi√° m·∫°nh (BOS/CHOCH tƒÉng)
    # Bearish OB: N·∫øn tƒÉng cu·ªëi c√πng tr∆∞·ªõc m·ªôt ƒë·ª£t gi·∫£m gi√° m·∫°nh (BOS/CHOCH gi·∫£m)
    df['OB'] = 0
    df['Top_OB'] = np.nan
    df['Bottom_OB'] = np.nan

    for i in range(1, len(df)):
        # N·∫øu c√≥ t√≠n hi·ªáu tƒÉng gi√° m·∫°nh
        if df['bos_choch_signal'].iloc[i] in [1, 2]:
            # T√¨m n·∫øn gi·∫£m g·∫ßn nh·∫•t
            for j in range(i - 1, max(0, i - 10), -1):
                if df['close'].iloc[j] < df['open'].iloc[j]: # N·∫øn gi·∫£m
                    df.loc[df.index[j], 'OB'] = 1 # Bullish OB
                    df.loc[df.index[j], 'Top_OB'] = df['high'].iloc[j]
                    df.loc[df.index[j], 'Bottom_OB'] = df['low'].iloc[j]
                    break
        # N·∫øu c√≥ t√≠n hi·ªáu gi·∫£m gi√° m·∫°nh
        elif df['bos_choch_signal'].iloc[i] in [-1, -2]:
            # T√¨m n·∫øn tƒÉng g·∫ßn nh·∫•t
            for j in range(i - 1, max(0, i - 10), -1):
                if df['close'].iloc[j] > df['open'].iloc[j]: # N·∫øn tƒÉng
                    df.loc[df.index[j], 'OB'] = -1 # Bearish OB
                    df.loc[df.index[j], 'Top_OB'] = df['high'].iloc[j]
                    df.loc[df.index[j], 'Bottom_OB'] = df['low'].iloc[j]
                    break
    
    # --- 4. X√°c ƒë·ªãnh Fair Value Gaps (FVG) ---
    df['FVG'] = 0
    df['Top_FVG'] = np.nan
    df['Bottom_FVG'] = np.nan

    for i in range(2, len(df)):
        # Bullish FVG: ƒê√°y n·∫øn 1 > ƒê·ªânh n·∫øn 3
        if df['low'].iloc[i-2] > df['high'].iloc[i]:
            df.loc[df.index[i-1], 'FVG'] = 1
            df.loc[df.index[i-1], 'Top_FVG'] = df['low'].iloc[i-2]
            df.loc[df.index[i-1], 'Bottom_FVG'] = df['high'].iloc[i]
        # Bearish FVG: ƒê·ªânh n·∫øn 1 < ƒê√°y n·∫øn 3
        elif df['high'].iloc[i-2] < df['low'].iloc[i]:
            df.loc[df.index[i-1], 'FVG'] = -1
            df.loc[df.index[i-1], 'Top_FVG'] = df['high'].iloc[i-2]
            df.loc[df.index[i-1], 'Bottom_FVG'] = df['low'].iloc[i]

    # --- 5. X√°c ƒë·ªãnh Liquidity Sweeps ---
    # T·∫°m th·ªùi ƒë∆°n gi·∫£n h√≥a: m·ªôt c√¢y n·∫øn c√≥ r√¢u d√†i qu√©t qua ƒë·ªânh/ƒë√°y g·∫ßn nh·∫•t
    df['Swept'] = 0
    recent_high = df['high'].rolling(5).max().shift(1)
    recent_low = df['low'].rolling(5).min().shift(1)
    
    # Bearish sweep (qu√©t ƒë·ªânh)
    df.loc[(df['high'] > recent_high) & (df['close'] < recent_high), 'Swept'] = -1
    # Bullish sweep (qu√©t ƒë√°y)
    df.loc[(df['low'] < recent_low) & (df['close'] > recent_low), 'Swept'] = 1
    
    return df


# --- Chi·∫øn l∆∞·ª£c Freqtrade ---
class AdvancedSMC(IStrategy):
    """
    Chi·∫øn l∆∞·ª£c n√†y s·ª≠ d·ª•ng c√°c kh√°i ni·ªám Smart Money Concepts (SMC) n√¢ng cao
    v·ªõi ph√¢n t√≠ch ƒëa khung th·ªùi gian (Multi-Timeframe Analysis).
    
    *** PHI√äN B·∫¢N N√ÄY KH√îNG S·ª¨ D·ª§NG TH∆Ø VI·ªÜN B√äN NGO√ÄI ƒê·ªÇ TR√ÅNH XUNG ƒê·ªòT ***
    """
    
    # --- C·∫•u h√¨nh Chi·∫øn l∆∞·ª£c ---
    INTERFACE_VERSION = 3
    minimal_roi = {"0": 100}
    stoploss = -0.10
    timeframe = '5m'
    informative_timeframes = ['15m', '1h', '4h', '1d']
    process_only_new_candles = True
    startup_candle_count: int = 200
    use_exit_signal = True
    exit_profit_only = False
    ignore_roi_if_entry_signal = True

    # --- Population c·ªßa Indicators ---
    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        # --- Ph√¢n t√≠ch tr√™n T·∫§T C·∫¢ Khung Th·ªùi Gian Cao (HTF) ---
        for htf in self.informative_timeframes:
            informative_df = self.dp.get_pair_dataframe(pair=metadata['pair'], timeframe=htf)
            
            # --- √Åp d·ª•ng h√†m ph√¢n t√≠ch SMC th·ªß c√¥ng ---
            informative_df = analyze_smc_features(informative_df)

            # --- G·ªôp d·ªØ li·ªáu HTF v√†o LTF ---
            informative_df.rename(columns={
                'BOS': f'htf_bos_{htf}', 'CHOCH': f'htf_choch_{htf}', 
                'OB': f'htf_ob_{htf}', 'Top_OB': f'htf_ob_top_{htf}', 'Bottom_OB': f'htf_ob_bottom_{htf}',
                'FVG': f'htf_fvg_{htf}', 'Top_FVG': f'htf_fvg_top_{htf}', 'Bottom_FVG': f'htf_fvg_bottom_{htf}'
            }, inplace=True)
            
            required_cols = [
                'date', f'htf_bos_{htf}', f'htf_choch_{htf}', f'htf_ob_{htf}', 
                f'htf_ob_top_{htf}', f'htf_ob_bottom_{htf}', f'htf_fvg_{htf}', 
                f'htf_fvg_top_{htf}', f'htf_fvg_bottom_{htf}'
            ]
            existing_cols = [col for col in required_cols if col in informative_df.columns]
            informative_df_subset = informative_df[existing_cols].copy()

            dataframe = merge_informative_pair(dataframe, informative_df_subset, self.timeframe, htf, ffill=True)

        # --- Ph√¢n t√≠ch tr√™n Khung Th·ªùi Gian Th·∫•p (LTF) ---
        dataframe = analyze_smc_features(dataframe)

        return dataframe

    # --- Logic V√†o L·ªánh ---
    def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        higher_timeframes = [tf for tf in self.informative_timeframes if tf != '15m']

        # --- ƒêi·ªÅu ki·ªán chung cho L·ªánh Mua (Long) ---
        htf_bullish_bos = [dataframe[f'htf_bos_{htf}'] == 1 for htf in higher_timeframes]
        htf_bullish_poi = []
        for htf in higher_timeframes:
            in_ob = (dataframe['low'] <= dataframe[f'htf_ob_top_{htf}']) & (dataframe['high'] >= dataframe[f'htf_ob_bottom_{htf}']) & (dataframe[f'htf_ob_{htf}'] == 1)
            in_fvg = (dataframe['low'] <= dataframe[f'htf_fvg_top_{htf}']) & (dataframe['high'] >= dataframe[f'htf_fvg_bottom_{htf}']) & (dataframe[f'htf_fvg_{htf}'] == 1)
            htf_bullish_poi.append(in_ob | in_fvg)

        # --- ƒêi·ªÅu ki·ªán chung cho L·ªánh B√°n (Short) ---
        htf_bearish_bos = [dataframe[f'htf_bos_{htf}'] == -1 for htf in higher_timeframes]
        htf_bearish_poi = []
        for htf in higher_timeframes:
            in_ob = (dataframe['low'] <= dataframe[f'htf_ob_top_{htf}']) & (dataframe['high'] >= dataframe[f'htf_ob_bottom_{htf}']) & (dataframe[f'htf_ob_{htf}'] == -1)
            in_fvg = (dataframe['low'] <= dataframe[f'htf_fvg_top_{htf}']) & (dataframe['high'] >= dataframe[f'htf_fvg_bottom_{htf}']) & (dataframe[f'htf_fvg_{htf}'] == -1)
            htf_bearish_poi.append(in_ob | in_fvg)

        # --- K·∫øt h·ª£p ƒëi·ªÅu ki·ªán v√† t·∫°o t√≠n hi·ªáu ---
        dataframe.loc[
            (
                reduce(lambda a, b: a | b, htf_bullish_bos) &
                reduce(lambda a, b: a | b, htf_bullish_poi) &
                (dataframe['Swept'] == 1) &
                (dataframe['CHOCH'].shift(1) == 1) &
                (dataframe['htf_choch_15m'] != -1)
            ),
            ['enter_long', 'enter_tag']] = (1, 'long_smc_manual')
        
        dataframe.loc[
            (
                reduce(lambda a, b: a | b, htf_bearish_bos) &
                reduce(lambda a, b: a | b, htf_bearish_poi) &
                (dataframe['Swept'] == -1) &
                (dataframe['CHOCH'].shift(1) == -1) &
                (dataframe['htf_choch_15m'] != 1)
            ),
            ['enter_short', 'enter_tag']] = (1, 'short_smc_manual')

        return dataframe

    # --- Logic Tho√°t L·ªánh ---
    def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        dataframe.loc[(dataframe['CHOCH'] == -1), 'exit_long'] = 1
        dataframe.loc[(dataframe['CHOCH'] == 1), 'exit_short'] = 1
        return dataframe

    # --- T∆∞∆°ng t√°c qua Telegram ---
    def rpc_smc_status(self, pair: str, **kwargs) -> dict:
        dataframe = self.dp.get_analyzed_dataframe(pair=pair, timeframe=self.timeframe)
        if dataframe.empty:
            return {"error": f"Kh√¥ng c√≥ d·ªØ li·ªáu cho c·∫∑p {pair}."}
        
        last_candle = dataframe.iloc[-1].to_dict()
        message = f"üîç **Ph√¢n t√≠ch SMC cho {pair} (Th·ªß c√¥ng)**\n"
        message += f"------------------------------------\n"
        sorted_timeframes = sorted(self.informative_timeframes, key=lambda x: pd.to_timedelta(x.replace('d', 'days').replace('w', 'weeks')), reverse=True)
        
        for htf in sorted_timeframes:
            htf_bos_val = last_candle.get(f'htf_bos_{htf}')
            htf_choch_val = last_candle.get(f'htf_choch_{htf}')
            htf_bos = "TƒÉng" if htf_bos_val == 1 else "Gi·∫£m" if htf_bos_val == -1 else "Kh√¥ng r√µ"
            htf_choch = "TƒÉng" if htf_choch_val == 1 else "Gi·∫£m" if htf_choch_val == -1 else "Kh√¥ng c√≥"
            message += (f"**Khung ({htf}):**\n  - Xu h∆∞·ªõng (BOS): **{htf_bos}**\n  - ƒê·∫£o chi·ªÅu (CHoCH): **{htf_choch}**\n")
        
        ltf_choch_val = last_candle.get('CHOCH')
        liquidity_swept_val = last_candle.get('Swept')
        ltf_choch = "TƒÉng" if ltf_choch_val == 1 else "Gi·∫£m" if ltf_choch_val == -1 else "Kh√¥ng c√≥"
        liquidity_swept = "Qu√©t ƒë√°y" if liquidity_swept_val == 1 else "Qu√©t ƒë·ªânh" if liquidity_swept_val == -1 else "Kh√¥ng c√≥"
        
        message += (
            f"------------------------------------\n"
            f"**Khung ({self.timeframe}):**\n"
            f"  - ƒê·∫£o chi·ªÅu (CHoCH): **{ltf_choch}**\n"
            f"  - Qu√©t thanh kho·∫£n: **{liquidity_swept}**\n"
            f"------------------------------------\n"
            f"C·∫≠p nh·∫≠t l√∫c: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        )
        return {"msg": message}
